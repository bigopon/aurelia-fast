<script>
  const MODE_SLASH = 0;
  const MODE_TEXT = 1;
  const MODE_WHITESPACE = 2;
  const MODE_TAGNAME = 3;
  const MODE_COMMENT = 4;
  const MODE_PROP_SET = 5;
  const MODE_PROP_APPEND = 6;
  
  const CHILD_APPEND = 0;
  const CHILD_RECURSE = 2;
  const TAG_SET = 3;
  const PROPS_ASSIGN = 4;
  const PROP_SET = MODE_PROP_SET;
  const PROP_APPEND = MODE_PROP_APPEND;
  
  const build = function(statics) {
    const fields = arguments;
    const h = this;
  
    let mode = MODE_TEXT;
    let buffer = '';
    let quote = '';
    let current = [0];
    let char, propName;
    let syntheticCount = 0;
  
    const commit = field => {
      if (mode === MODE_TEXT && (field || (buffer = buffer.replace(/^\s*\n\s*|\s*\n\s*$/g,'')))) {
        current.push(field ? fields[field] : buffer);
      }
      else if (mode === MODE_TAGNAME && (field || buffer)) {
        current[1] = field ? fields[field] : buffer;
        mode = MODE_WHITESPACE;
      }
      else if (mode === MODE_WHITESPACE && buffer === '...' && field) {
        current[2] = Object.assign(current[2] ??= {}, fields[field]);
      }
      else if (mode === MODE_WHITESPACE && buffer && !field) {
        (current[2] ??= {})[buffer] = true;
      }
      else if (mode === MODE_WHITESPACE && !buffer && field) {
        (current[2] ??= {})[`a__${syntheticCount}`] = fields[field];
      }
      else if (mode >= MODE_PROP_SET) {
        if (mode === MODE_PROP_SET) {
          (current[2] = current[2] || {})[propName] = field ? buffer ? (buffer + fields[field]) : fields[field] : buffer;
          mode = MODE_PROP_APPEND;
        }
        else if (field || buffer) {
          current[2][propName] += field ? buffer + fields[field] : buffer;
        }
      }
  
      buffer = '';
    };
  
    for (let i = 0; i < statics.length; i++) {
      if (i) {
        if (mode === MODE_TEXT) {
          commit();
        }
        commit(i);
      }
  
      for (let j = 0; j < statics[i].length; j++) {
        char = statics[i][j];
  
        if (mode === MODE_TEXT) {
          if (char === '<') {
            // commit buffer
            commit();
            current = [current, '', null];
            mode = MODE_TAGNAME;
          }
          else {
            buffer += char;
          }
        }
        else if (mode === MODE_COMMENT) {
          // Ignore everything until the last three characters are '-', '-' and '>'
          if (buffer === '--' && char === '>') {
            mode = MODE_TEXT;
            buffer = '';
          }
          else {
            buffer = char + buffer[0];
          }
        }
        else if (quote) {
          if (char === quote) {
            quote = '';
          }
          else {
            buffer += char;
          }
        }
        else if (char === '"' || char === "'") {
          quote = char;
        }
        else if (char === '>') {
          commit();
          mode = MODE_TEXT;
        }
        else if (!mode) {
          // Ignore everything until the tag ends
        }
        else if (char === '=') {
          mode = MODE_PROP_SET;
          propName = buffer;
          buffer = '';
        }
        else if (char === '/' && (mode < MODE_PROP_SET || statics[i][j+1] === '>')) {
          commit();
          if (mode === MODE_TAGNAME) {
            current = current[0];
          }
          mode = current;
          (current = current[0]).push(h.apply(null, mode.slice(1)));
          mode = MODE_SLASH;
        }
        else if (char === ' ' || char === '\t' || char === '\n' || char === '\r') {
          // <a disabled>
          commit();
          mode = MODE_WHITESPACE;
        }
        else {
          buffer += char;
        }
  
        if (mode === MODE_TAGNAME && buffer === '!--') {
          mode = MODE_COMMENT;
          current = current[0];
        }
      }
    }
    commit();
  
    return current.length > 2 ? current.slice(1) : current[1];
  };
  
  class TemplateNode {
    constructor(name, attrs, children) {
      this.name = name;
      this.attrs = attrs;
      this.children = children;
    }
  }
  
  function toNode(name, attrs, ...children) {
    return new TemplateNode(name, attrs, children);
  }
  
  // Much thanks to LitHTML for working this out!
  const lastAttributeNameRegex =
      // eslint-disable-next-line no-control-regex
      /([ \x09\x0a\x0c\x0d])([^\0-\x1F\x7F-\x9F "'>=/]+)([ \x09\x0a\x0c\x0d]*=[ \x09\x0a\x0c\x0d]*(?:[^ \x09\x0a\x0c\x0d"'`<>=]*|"[^"]*|'[^']*))$/;
  
  function html(strings, ...values) {
    return build.call(toNode, strings, ...values);
  }
  
  function on(n, fn) {
    return fn;
  }
  
  function Comp() {}
  
  console.log(html`
    <div ${5} />
    <${Comp} />
    <div b=${5} ${on('click', a => a)} />
    <p>
      <span>Hello</span>
    </p>
    <div>${x => x.name}</>`
  )
  
  </script>
  <body></body>
  <script>
    document.body.innerHTML = 'ready';
  </script>
  